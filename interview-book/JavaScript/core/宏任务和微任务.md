## 事件循环

js 事件循环 是 js 处理异步任务的核心机制，使 js 能在单线程的环境下高效的处理异步任务。

事件循环的主要步骤：

1. 执行同步任务
   js 首先执行调用栈中的同步任务，直到栈顶的任务完成。
2. 处理微任务
   - 当同步任务执行完毕后，事件循环会检查微任务队列，并按顺序执行所有微任务，直到队列为空。微任务包括 Promise 的回调（Promise.then, Promise.catch），async/await MutationObserve 等。
   - await 之前的代码是同步的，await 执行之后的函数，然后返回一个 promise，把 await 下面的代码放到微任务中，并且退出这个 async 函数
3. 支持宏任务
   微任务队列清空后，事件循环会从宏任务队列中取出一个任务执行。宏任务包括 script 标签整体代码、setTimeout、setInterval、setImmediate、I/O、UI rendering 等。
4. UI 渲染
   当宏任务执行完毕后，且微任务队列为空时，事件循环会检查 UI 渲染，并执行所有待渲染的 UI 更新。
5. 重复以上步骤

## 宏任务和微任务

宏任务： 是由宿主环境（浏览器、node.js）发起的异步任务：

1. script 标签整体代码
2. setTimeout
3. setInterval
4. setImmediate (node.js)
5. requestAnimationFrame (浏览器)
6. I/O 操作（如：ajax 请求、文件读取等）
7. UI rendering (浏览器)

微任务： 是由 js 引擎发起的异步任务：

1. Promise.then, Promise.catch , async/await
2. process.nextTick (node.js)
3. MutationObserver (浏览器,接口提供了监视对 DOM 树所做更改的能力)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTTP 请求示例</title>
    <!-- 这里使用 <script> 标签加载外部 JavaScript 文件，这是一个 HTTP 请求 -->
    <script src="https://example.com/script.js"></script>
  </head>

  <body>
    <img src="https://example.com/image.jpg" alt="Example Image" />
    <script>
      console.log('主线程开始执行')

      // 使用 fetch 发起 HTTP 请求
      fetch('https://api.example.com/data')
        .then((response) => response.json())
        .then((data) => {
          console.log('fetch 请求返回的数据:', data)
        })
        .catch((error) => {
          console.error('fetch 请求出错:', error)
        })

      console.log('主线程执行结束')
    </script>
  </body>
</html>
```

script 标签加载外部 js， img 标签加载图片，fetch 请求发起 http 请求。都是宏任务

利用微任务处理大量 DOM 更新：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>微任务优化 DOM 更新</title>
  </head>

  <body>
    <div id="container"></div>
    <script>
      const container = document.getElementById('container')
      const updates = []

      // 模拟多次 DOM 更新操作
      function updateDOM() {
        for (let i = 0; i < 100; i++) {
          updates.push(() => {
            const newElement = document.createElement('p')
            newElement.textContent = `Item ${i}`
            container.appendChild(newElement)
          })
        }

        // 使用微任务统一处理更新操作
        Promise.resolve().then(() => {
          updates.forEach((update) => update())
        })
      }

      updateDOM()
    </script>
  </body>
</html>
```

将 100 次 DOM 更新操作存储在 updates 数组中，然后使用 Promise.resolve().then 将这些更新操作放入微任务中。这样，在一次事件循环中，这些更新操作会被统一处理，减少了重排和重绘的次数，提高了页面的性能。
