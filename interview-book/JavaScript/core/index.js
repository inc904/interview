/*
 



## 闭包

- 定义：有权访问另一个函数作用域中的变量的函数



*/

/*
##  预编译

//  单线程、解释型语言

执行的时候，解释一行，执行一行

js 运行 三部曲：

- 语法分析
- 预编译
- 解释执行

但是 在解释之前，系统会扫描一遍代码，查看代码有没有低级错误，将代码中可能出现的变量、函数等提前声明

 */

test(); // 正常打印 "test"
function test() {
  console.log("test");
}

console.log(a); // undefined
var a = 100;

console.log(b); // 报错

/*
 * 1. 函数声明 整体提升
 * 2. 变量 声明提升，但是赋值不提升
 */

console.log(a);
function a() {}
var a = 123;

/**
 
预编译前奏：
1. imply global 暗示全局变量：任何变量，如果变量未经声明就赋值，此变量就为全局对象所有。

    a = 123
    var c = 123
    var a = b = 123 ==> var a = 123; b = 123 ==> 在全局作用域内， 全局变量 a,b = 123, 
    
    在funtion 中
    function test() {
        var a = b = 123;
    }

    test()
    a 是局部变量， b 是全局变量 window.b = 123

2. 一切声明的全局变量，全是 window 的属性 

var a = 123 ==> window.a = 123

window 就是全局的域
*/

/**
  预编译 四部曲

  1. 创建AO对象 Activation Object 执行期上下文
  2. 找形参和变量声明，将变量名和形参名作为AO属性名，值为undefined
  3. 将实参值和形参统一
  4. 在函数体里面找函数声明，值赋予函数体


  预编译发生在函数执行的前一刻

 */

/**
   * 
    ## 作用域
        - 定义：变量（变量作用域又称上下文）和函数生效的（能被访问）的区域
        - 全局变量、局部变量
        - 作用域访问的顺序
   */

        运行期上下文： 当函数执行时，会创建一个称为 执行期上下文的内部对象。
        一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文被销毁。
        当函数执行完毕，他所产生的执行上下文被销毁。


        查找变量： 从当前的上下文开始查找，如果没有找到，就向上一级查找，直到找到全局上下文的变量对象，
        从作用域的顶端开始查找，逐级向上查找，直到找到为止。

        [[scope]]: [[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。
        作用域链： [[scope]] 中存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。