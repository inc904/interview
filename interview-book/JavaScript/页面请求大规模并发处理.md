# 如何解决页面请求接口大规模并发问题

**_滑动窗口_**， 算法， 专门来控制流量的，优化并发问题，

## 背景

数据采集平台，地代码编辑平台，有序的并相对稳定的发送到后端

## 方案

### 请求队列

```js
class RequestQueue {
  constructor(maxConcurrent) {
    this.maxConcurrent = maxConcurrent // 最大请求并发数
    this.currentConcurrent = 0 // 当前并发数
    this.queue = []
  }
  add(request) {
    return new Promise((resolve, reject) => {
      this.queue.push({ resolve, reject, request })
      this.processQueue()
    })
  }
  processQueue() {
    if (this.currentConcurrent < this.maxConcurrent && this.queue.length > 0) {
      const { resolve, reject, request } = this.queue.shift()
      this.currentConcurrent++
      request()
        .then(resolve)
        .catch(reject)
        .finally(() => {
          this.currentConcurrent--
          this.processQueue()
        })
    }
  }
}

// 示例请求函数
function fetchData(url) {
  return fetch(url).then((res) => res.json())
}

// 使用请求队列
const requestQueue = new RequestQueue(10)
const urls = [
  'https://api.example.com/data1',
  'https://api.example.com/data2',
  // ... other urls
]
const requests = urls.map((url) => fetchData(url))
Promise.all(requests.map((request) => requestQueue.add(request)))
  .then((results) => {
    console.log('所有请求完成：', results)
  })
  .catch((error) => {
    console.error('请求出错：', error)
  })
```

### 防抖/节流

### 分页加载
