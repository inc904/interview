# 防抖和节流

## 是什么？

防抖和节流都是优化高频率执行代码的手段。
为了优化体验，希望对调用次数进行限制。

定义：

节流：n 秒被只运行一次，若在 n 秒内重复触发，只有第一次生效。
防抖：n 秒后再执行该事件，若在 n 秒内被重复触发，则重新计时。

## 实现

### 节流

- 时间戳写法，事件会立即执行，停止出发后没有办法再次执行

```js
function throttle(fn, delay = 500) {
  let oldTIme = Date.now()
  return function (...args) {
    let newTime = Date.now()
    if (newTime - oldTIme >= delay) {
      fn.apply(null, args)
      oldTime = Date.now()
    }
  }
}
```

- 定时器写法, delay 后第一次执行，停止触发后依然会执行一次

```js
function throttle(fn, delay = 500) {
  let timer = null
  let startTime = Date.now()
  return function (...args) {
    let curTime = Date.now()
    let remaining = delay - (curTime - startTime) // 从上一次执行到现在，还剩下多少时间
    let that = this
    clearTimeout(timer)
    if (remaining <= 0) {
      fn.apply(that, args)
      startTime = Date.now()
    } else {
      timer = setTimeout(() => {
        fn, remaining
      })
    }
  }
}
```

### 防抖

```js
function debounce(fn, wait = 500) {
  let timeout = null
  return function (...args) {
    let that = this
    let args = arguments
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      fn.apply(that, args)
    }, wait)
  }
}
```

防抖如果需要立即执行， 可假如第三个参数用于判断:

```js
function debounce(fn, wait = 500, immediate = false) {
  let timeout = null
  return function () {
    let that = this
    let args = arguments
    if (timeout) clearTimeout(timeout)
    if (immediate) {
      let callNow = !timeout // 第一次会立即执行，以后只有事件执行后才会再次触发
      timeout = setTimeout(() => {
        timeout = null
      }, wait)
      if (callNow) fn.apply(that, args)
    } else {
      timeout = setTimeout(() => {
        fn.apply(that, args)
      }, wait)
    }
  }
}
```

## 区别

相同点：

- 都可以通过使用 setTimeout 来实现。
- 目的都是减少函数执行次数。节省资源

不同点：

- 函数防抖，在一段连续操作结束后，处理回调，利用 setTimeout 和 clearTimeout 实现。
- 函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提升性能。
- 函数防抖关注一定时间连续触发的事件，只在最后一次执行，而函数就列一点时间内只执行一次
