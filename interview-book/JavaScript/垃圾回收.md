# 垃圾回收

1. js 的内存分为栈内存（存储基本类型和引用指针）和堆内存（存储对象和数组）。垃圾回收主要针对堆内存的对象进行处理。
2. 垃圾对象指的是不可达对象，即没有引用指向该对象，所以该对象可以回收。
   - 无法通过根对象（如全局变量，执行上下文中的局部变量，DOM 元素）遍历

## 垃圾回收算法

1. 引用计数法

- 原理： 跟踪每一个对象的引用次数，引用次数为 0 时，立即回收
- 无法处理循环引用（A 引用 B，B 引用 A），导致内存泄露
- 早期 IE 使用这种算法，但存在问题，所以现在基本不使用这种算法。

2. 标记清除法

- 原理： 从根对象出发，标记所有可到达的对象，然后清除不可到达的对象
- 能解决循环引用问题，广泛应用与现代浏览器（如 chrome v8 引擎）
- 缺点： 标记清除算法需要遍历整个堆内存，效率较低，且需要额外的内存空间，导致内存碎片化，影响分配效率

3. 标记-整理算法

- 原理： 在标记清除后，将存活对象向内存一端移动，合并空闲空间，减少碎片化

## 现代引擎的优化策略

1. 分代回收

- 新生代：存放短生命周期对象，采用复制算法（将存活对象复制到另一块内存，清空原区域），效率高且无碎片化

- 老年代：存放长生命周期对象，使用增量标记-清除算法，分阶段标记以减少卡顿

2. 增量垃圾回收

- 将标记过程拆分为多个小步骤，分散执行，避免长时间阻塞主线程。

3. V8 引擎的优化策略

- 新生代 使用 scavenge 算法（并行执行）
- 老生代 使用 增量标记+整机算法

## 内存泄露的原因及优化

1. 循环引用：两个对象互相引用但无法被外部访问，导致两个对象都无法被回收，导致内存泄露。
2. 闭包：函数中包含外部作用域的变量，导致外部作用域无法被回收，导致内存泄露。
3. 监听事件：监听事件未解绑导致内存泄露，如监听 DOM 元素的点击事件，导致点击事件无法被移除，导致内存泄露。setInterval 未移除
4. 全局变量滥用： 未及时删除全局作用域中的变量

优化：

1. 避免不必要的循环引用，使用 null 主动解绑对象
2. 及时清理事件监听器和定时器
3. 利用 weakMap 和 weakSet 管理弱引用对象
4. 开发者工具分析 内存泄露
