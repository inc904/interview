# vue 生命周期

## vue2 生命周期

vue2 有 8 个系统自带的生命周期函数：

1. 创建数据代理、数据检测

   - beforeCreate
     - 在实例初始化之后，进行数据坚挺和事件、侦听器的配置之前同步调用
     - 此时还没有进行数据代理，数据检测，所以 vm 的身上并没有 `_data` 属性
   - created
     - 在实例创建完成后立即同步调用。这一步中实例已经完成对选项的处理，也就意味着 `data` 选项中的数据已经被代理到 `vm` 上了，并且 `$watch` 侦听器已经开始工作。（数据侦听、计算属性、方法、事件/侦听器的配置已经完成）但没有 `el`

2. 挂载

   - beforeMount
     - 此时页面呈现的是`未经 vue 编译`的 DOM 结构，所以 所有对 DOM 的操作都不 奏效
     - 该钩子在服务器端渲染期间不被调用
   - mounted
     - 既有 `el` 又有 `data`
     - 实例被挂载后调用，页面中的插值语法已经被解析了。该钩子在服务器端渲染不被调用
     - `mounted` 也不保证所有 子组件 都被挂载完成，如果你希望在整个视图都渲染完成后再执行某些操作，可以在 `mounted` 内部使用 `nextTick`
     - 对 DOM 的操作有效，但是也要尽量避免
     - 一般在此处进行： 开启定时器、发送网络请求、订阅消息、绑定自定义事件等

3. 更新

   - beforeUpdate
     - 在数据发生改变后，DOM 被更新之前调用
     - 该钩子在服务器端渲染不可被调用，因为只有初次渲染会在服务器进行
     - `此处数据是新的，但是页面是旧的`, 页面和数据没有保持同步更新
   - updated
     - 数据是新的，页面也是新的（但不保证所有子组件也都被渲染完毕）
     - 如果希望等到整个视图都渲染完毕，可以在 updated 中使用 `nextTick`

4. 销毁

   - beforeDestroy
     - 在实例销毁之前调用，在这一步，实例仍然可用
     - 该钩子在服务端渲染不可被调用，因为只有初次渲染会在服务器进行
   - destroyed
     - 在实例销毁后调用。该钩子被调用之后，对应的 vue 实例的所有指令都被解绑，所有的事件监听器都被移除，所有的子实例也会被销毁。
     - 该钩子在服务器端渲染不可被调用，因为只有初次渲染会在服务器进行

5. 激活
   VueRouter 路由组件所独有的两个钩子，用于捕获路由组件的激活状态

   - activated
     - 被 keep-active 缓存的组件激活时调用，在服务端渲染期间不可调用
   - deactivated
     - 在 keep-alive 缓存的组件停用时调用，在服务端渲染期间不可调用

6. 异步更新

- errorCaptured - 2.5.0+ 新增，在捕获一个来自后代组件的错误时被调用。钩子 函数会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。

## vue3 生命周期

vue3.0 对生命周期钩子重构。

1. setup

   开始创建组件之前执行，是组合式 API 的入口点，此时尚未创建组件实例，因此无法访问 `this`

2. onBeforeMount

   组件挂载到节点上之前执行的函数

3. onMounted

   组件挂载到节点上之后执行的函数

4. onBeforeUpdate

   组件更新之前执行的函数

5. onUpdated

   组件更新之后执行的函数

6. onBeforeUnmount

   组件卸载之前执行的函数， 替代了 vue2 中的 beforeDestory

7. onUnmounted

   组件卸载之后执行的函数， 替代了 vue2 中的 destroyed

8. onActivated(): 被包含在 `<keep-alive>` 中的组件，会多出两个生命周期钩子函数，被激活时执行；

9. onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行；

10. onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数
