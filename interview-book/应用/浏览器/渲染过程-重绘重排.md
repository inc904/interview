渲染过程：

1. 解析 html，生成 DOM 树
2. 解析 css， 生成 css object model
3. 构建 渲染树 ， 合并 css object model 和 DOM 树
4. 布局，计算位置和尺寸，确定集合信息（宽高，边框）
5. 绘制： 将元素转换为屏幕上的像素
6. 合成： 将多个图层合并，通过 GPU 加速绘制到屏幕上

# 重排（回流，reflow）

当元素布局（位置、尺寸、边、字体大小）变化，浏览器需要重新计算布局并更新渲染树

- 几何属性（宽高、边框、边距、字体大小）
- 添加或者删除元素
- 改变窗口大小吗
- 修改元素的 display 属性（none-block）

会导致其子元素和祖先元素重新计算，甚至触发整个页面的回流，性能开销最大

### 重绘（repaint）

- 修改 元素的颜色、背景色、边框样式、阴影等不会影响几何属性的属性
- 修改元素的 visibility 属性为 hidden （元素隐藏但保留布局空间）

## 有优化

1. 减少重排 / 重绘

- 批量修改 DOM：使用文档片段（DocumentFragment）或虚拟 DOM（如 React）减少直接操作。
- 缓存布局信息：避免连续读取和修改布局相关属性（如 offsetWidth、scrollTop）。
- 使用 CSS transforms：通过 GPU 加速平移、旋转等动画，避免触发重排。

2. 避免强制同步布局

- 浏览器会优化批量读取和写入，但连续读写布局属性可能导致强制同步（如 offsetWidth 后立即修改样式）。

3. 合理使用 will-change

-` 提示浏览器`对特定元素的变化进行优化（如 will-change: transform），提前分配资源。

4. 分层优化

- 将频繁变化的元素单独分层（如 position: fixed），减少对其他层的影响。
