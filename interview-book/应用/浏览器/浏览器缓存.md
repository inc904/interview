# 浏览器缓存

浏览器缓存是一种保留资源副本并在下一次请求时使用该副本的技术。它用于优化网络请求，减少网络流量，提高页面加载速度。

当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。

缓存的好处：

- 缓解服务器压力：缓存可以减少对服务器的请求，从而提高性能。
- 提升性能：打开本地资源比访问远程资源回来再打开快很多 å
- 减少流量：减少贷款消耗

缓存在宏观上可以分为两类：

- 私有缓存：只用于单独用户，最常见的就是浏览器缓存，也是本文要讨论的
- 共享缓存：多个用户共享，能被各级代理缓存，如 CDN，缓存服务器等

## 浏览器的缓存策略

浏览器对于缓存是根据 `第一次请求资源时返回的响应头`来确定的

<!-- 根据响应头中的 `Cache-Control` 和 `Expires` 来确定缓存的策略 -->

根据响应头，浏览器缓存策略一般分为三种： 强缓存、协商缓存、启发式缓存

### 浏览器缓存中常见的字段和指令

表格如下：

| 字段          | 含义                                                        |
| ------------- | ----------------------------------------------------------- |
| expires       | 告知客户端缓存失效的绝对时间                                |
| last-modified | 资源最后一次修改的时间                                      |
| Etag          | 文件的特殊标识，资源的版本号                                |
| Cache-Control | 缓存控制指令，告知客户端服务器如何处理缓存                  |
| private       | 告知客户端浏览器私有缓存，不能被 CDN 等中间层服务器缓存共享 |
| public        | 客户端和代理服务器都可缓存没有明确 private，就是 public     |
| no-cache      | 能缓存，但是每次要去服务端校验缓存                          |
| no-store      | 所有内容都不会被缓存                                        |
| max-age       | 缓存过期时间，单位秒                                        |

### 强缓存

强缓存是指浏览器在第一次请求资源时，会根据响应头中的 `expires` 和 `Cache-Control` 来确定缓存的策略，然后缓存该资源。当再次请求该资源时，浏览器会先查看本地缓存，如果存在，则直接返回本地缓存，而不会去服务器请求资源。

会给浏览器设置一个过期时间（未来时间），时间过期才会去重新请求。

#### expires

设置一个绝对时间，GMT 是个字符串，当浏览器时间超过这个时间之后，重新向服务器发送请求，重新下载资源。

- 弊端

  Expires 指令是客户端的，所以客户端可以修改时间，所以缓存失效时间可能会不准确。所以引入 cache-control： max-age 指令

#### Cache-Control： max-age 指令

Cache-Control： max-age=3600， 也是设置了一个过期时间，不同的是，他设置的是相对缓存时间开始往后的多少秒，是一个相对时间，因此不会受时间不准确的影响。

**优先级：**

max-age > expires， 当二者同时出现，expires 会被 max-age 覆盖。

#### 强缓存在浏览器上的表现

- firefox 浏览器对强缓存表现的是一个 灰色的 200 状态吗
- chrome 浏览器对强缓存表现的是一个 200 状态码，但是 size 为 （from disk cache 或者 from
  memory cache）。
  - 说明 Chrome 会根据本地内存的使用率来决定缓存存放在哪里，如果内存使用率很高，那么就会将缓存存放到本地磁盘中，如果磁盘使用率高，那么就会将缓存存放到内存中。

但是强缓存有一个问题，该缓存方式优先级很高，如果在过期时间内缓存的资源在服务器上更新了，那么客户端就不能及时获取最新的资源。于是就有了协商缓存。

### 协商缓存

协商缓存是利用 `Last-modified`,`if-Modified-Since` 和 `Etag`, `if-None-Match` 这两对 Header 来处理的。

## Last-Modified 和 If-Modified-Since

1. 浏览器第一次想服务器发送请求资源，服务器会在返回这个资源的同时，在 response `header` 中设置 `Last-Modified`， 这个 `header` 表示这个资源在服务器上的最后修改时间
2. 浏览器再次向服务器请求这个资源时，在 request 的 `header` 上加上 `If-Modified-Since`，这个 `header` 表示浏览器上次请求资源返回的 `Last-Modified` 时间。

3. 服务器再次受到请求资源时，根据浏览器传过来的 `If-Modified-Since` 和 资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 `304 Not Modified`， 但不会返回资源内容，如果有变化，返回 200， 就正常返回资源内容。
4. 浏览器受到 304 的响应后，就会从缓存加载资源。
5. 浏览器受到 200 的响应后，则从服务器加载新资源，`Last-Modified` header 在重新加载的时候会被更新，下次请求时，就会根据新的 `Last-Modified` header 和 `If-Modified-Since` header 来判断资源是否有变化。

- 弊端
  `Last-Modified` 和 `If-Modified-Since` 都是根据服务器时间返回的 Header， 一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 Header 配合起来管理 协商缓存是没有问题的，但是如果客户端的时间被篡改了，或者服务器时间被调整了，那么就会导致 `Last-Modified` 和`If-Modified-Since` 的值不对，就会导致协商缓存失效。
  还有就是这两个单位 计时的精度是秒，如果以小于秒的频率更新，那就检测不到了，所有这时引入 `Etag` 和 `If-None-Match`

## Etag 和 If-None-Match

1. 浏览器第一次跟服务端请求一个资源，服务器在返回这个资源的同时，在 response `header` 中设置 `Etag`， 这个 `header` 表示这个资源在服务器上的唯一标识字符串 ，这个标识是服务器生成的，是唯一的，而且不会随着服务器的时间改变而改变。比如： `Etag: "abcdefg-123123"` 只要这个资源由变化这个字符串就会变化
2. 浏览器再次根服务器请求这个资源时，在 request 的 `header` 上加上 `If-None-Match`，这个 `header` 表示浏览器上次请求资源返回的 `Etag`。
3. 服务器再次受到请求资源时，根据浏览器传过来的 `If-None-Match` 和 资源在服务器上的 `Etag` 判断资源是否有变化，如果没有变化则返回 `304 Not Modified`， 但不会返回资源内容，如果有变化，返回 200， 就正常返回资源内容。
4. 浏览器受到 304 的响应后，就会从缓存加载资源。
5. 浏览器受到 200 的响应后，则从服务器加载新资源，`Etag` 在重新加载的时候会被更新，下次请求时，就会根据新的 `Etag` 和 `If-None-Match` header 来判断资源是否有变化。

优先级： Etag > Last-Modified

## 启发式缓存

请求头中确定缓存过期时间的字段一个都没有，此时则会默认开始浏览器的启动时缓存。

浏览器会根据响应头中 2 个时间字段 Date 和 Last-modified 之间的时间差值，取其的 1/10 作为缓存过期时间。

优先级：

强缓存 > 协商缓存 > 启发式缓存

Cache-Control > Expires > Date + Last-modified

在检查是强缓存还是协商缓存之前， 浏览器会先检查 Cache-Control 是否为 no-store，如果为 no-store，则所有内容都不会被缓存，包括含强缓存，协商缓存，启发式缓存。

## 实际项目用到的缓存

用 webpack 打包文件，除了 index.html 入口文件不缓存，其他静态文件用 hash 值命名，hash 值不变就走 强缓存，否则就走协商缓存。

### 单页应用上线版本缓存控制

```conf
# nginx 禁止缓存 index.html 文件
location ~* .(html)$ {
  add_header Cache-Control no-store;
}
# js，css,图片 等强制缓存一个月
location ~* .(js|css|png|jpg|jpeg|gif|ico|woff|woff2|ttf|svg|map)$ {
add_header Cache-Control "max-age=2592000";
}
```

### http 同域名下的并发限制

#### 浏览器为什么有并发限制

- 对操作系统端口考虑
  PC 在端口为 65536，一个 TCP 连接就占用一个端口（http 也是一个 TCP），操作系统通常会对在端口一半开放对外请求，防止端口数量不被迅速消耗殆尽
- 过多并发导致频繁切换产生性能问题
  一个线程对应一个 http 请求，如果并发数量巨大的话，会导致线程频繁切换，而线程的上下文切换有时候并不是一个轻量级的资源

  所以请求控制器里面会产生一个链接池，以服用之前的链接（4-8 个）

- 避免统一客户端并发大量请求超过服务端的并发阈值
  服务端通常会对统一客户端来源设置并发阈值避免恶意攻击

#### 优化手段

- 静态资源优化
  - 将静态资源（如突图片、css、js）分布到多个域名下，增加并发请求数
  - 使用 CDN 加速资源加载
- 减少请求数量
  - 合并 css 和 js 文件
  - 使用雪碧图（css sprites）减少图片请求数量
- 升级到 HTTP/2
  - HTTP/2 默认支持多路复用，可以同时发送多个请求，同时接收多个响应，从而避免并发限制
  - 如果没有升级到 HTTP/2, 可是使用 域名分片，将一个 IP 映射多个域名（4 个左右，多了会导致 DNS 解析性能问题），随机放回这组域名中的一个，从而实现并发请求
- 预加载关键资源
  - 使用 preload 标签将关键资源提前加载到浏览器缓存中，从而减少请求数量，提高性能
    `<link rel="preload" href="main.js" as="script">`
