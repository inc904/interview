# 项目构建优化

## webpack 构建优化

### 一、 生产模式和开发模式

开发模式下默认不会优化输出，主要关注快速构建和热更新。
而生产模式下。webpack 会进行压缩和优化，以获得更小的文件。

使用环境变量（process.env.NODE_ENV）合理切换构建模式，可以显著提升开发和生产的构建效率。

### 二、合理配置 loader

1. 使用 `include` 和 `exclude`

   来减少匹配范围，限制 loader 只处理特定的文件，从而提高构建性能。

   ```js
   {
     module: {
       rules: [
         {
           test: /\.js$/,
           exclude: /node_modules/,
           use: ['babel-loader'],
         },
       ]
     }
   }
   ```

2. 使用 `cacheDirectory` 配置缓存

   一些 loader 支持缓存功能，可以加快开发过程中的构建速度。比如 babel-loader 支持缓存，可以通过 `cacheDirectory` 选项启动。

   ```js
   use:{
       loader: 'babel-loader',
       options: {
           cacheDirectory: true
       }
   }
   ```

### 三、多线程构建

1. 使用 `thread-loader` 多线程构建，利用 cpu 的多核性能

   ```js
   module: {
     rules: [
       {
         test: /\.js$/,
         use: ['thread-loader', 'babel-loader'],
       },
     ]
   }
   ```

2. `worker-loader` 允许将一宿耗时的操作放入 web worker 中执行，从而提高应用性能

### 四、优化构建配置

1. 使用 `SplitChunksPlugin` 可以把代码分割成多个块，以便更好的利用浏览器的缓存

   ```js
   optimization: {
       splitChunks: {
           chunks: 'all',
       }
   }
   ```

2. 异步代码，动态导入实现懒加载，只在有需要是才加载特定的模块，从而减少初始加载时间。

   ```js
   import('./foo.js').then((foo) => {
     foo.doSomething()
   })
   ```

3. 优化模块解析

   减少文件搜索范围，配置 extension,alias,modules

```js
resolve: {
  extensions: ['.js', '.jsx'], // 按需补充扩展名
  alias: { '@': path.resolve('src') },
  modules: [path.resolve(__dirname, 'src'), 'node_modules']
}
```

### 五、利用模块联邦（Module Federation）

webpack 5 引入了模块联邦（Module Federation），允许多个项目共享代码，从而减少重复代码。
可以将应用程序拆分为多个微服务，从而加快构建。

```js
module.exports = {
  // ...
  experiments: {
    outputModule: true,
  },
  output: {
    publicPath: 'auto',
  },

  // ...
}
```

### 六、使用缓存和增量编译

1. 硬盘缓存

   使用 webpack 的持久化缓存功能（webpack5 提供），可以减少构建时间

   ```js
   cache: {
     type: 'filesystem',
   }
   ```

2. 使用 `cache-loader`

   `cache-loader` 可以在构建过程中缓存 loader 的输出，从而减少重复构建时间。

   ```js
   module: {
     rules: [
       {
         test: /\.js$/,
         use: ['cache-loader', 'babel-loader'],
       },
     ]
   }
   ```

3. 生产环境 通过 `DLLPlugin` 提前打包更定的第三方库，减少重复编译。

### 七、 优化构建插件

1. 使用 `terser-webpack-plugin`，在生产模式下压缩 js 代码，以减小体积

   ```js
   const TerserPlugin = require('terser-webpack-plugin')
   module.exports = {
     optimization: {
       minimize: true,
       minimizer: [new TerserPlugin()],
     },
   }
   ```

   - 小图片 通过 url-loader 转为 base64，减少 http 请求

2. 使用 `mini-css-extract-plugin`，在生产模式下提取 css 代码，以减小体积

   ```js
   const MiniCssExtractPlugin = require('mini-css-extract-plugin')
   module.exports = {
     plugins: [
       new MiniCssExtractPlugin({
         filename: '[name].css',
       }),
     ],
   }
   ```

### 八、 使用开发服务器

1. 使用 `webpack-dev-server`，在开发模式下启动一个本地服务器，以提供热更新和实时编译。

   ```js
   const webpack = require('webpack')
   const webpackDevServer = require('webpack-dev-server')
   module.exports = {
     devServer: {
       contentBase: './dist',
       hot: true,
     },
   }
   ```

2. 优化 devServer 配置， 使用 watchOptions 选项来控制和减少文件监视的频率。

   ```js
   devServer: {
       watchOptions: {
           poll: 1000,
           aggregateTimeout: 500,
           ignored: /node_modules/,
       }
   }
   ```

### 九、分析构建性能

1. 使用 `webpack-bundle-analyzer`，在构建过程中分析打包结果，以了解哪些模块占用了过多的空间。

   ```js
   const BundleAnalyzerPlugin =
     require('webpack-bundle-analyzer').BundleAnalyzerPlugin
   module.exports = {
     plugins: [new BundleAnalyzerPlugin()],
   }
   ```

## vite 构建优化

## 项目优化
